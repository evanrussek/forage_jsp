geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_minimal()
ggplot(cond_lag, aes(x = travel_key_cond, y = mean_log_lag, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_basic()
ggplot(cond_lag, aes(x = travel_key_cond, y = mean_filt_lag, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_minimal()
ggplot(cond_lag, aes(x = travel_key_cond, y = mean_filt_lag2, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_minimal()
ggplot(cond_lag, aes(x = travel_key_cond, y = med_lag, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_minimal()
ggplot(cond_lag, aes(x = travel_key_cond, y = mean_log_lag, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_tufte()
ggplot(cond_lag, aes(x = travel_key_cond, y = mean_filt_lag, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_minimal()
ggplot(cond_lag, aes(x = travel_key_cond, y = mean_filt_lag2, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_minimal()
ggplot(cond_lag, aes(x = travel_key_cond, y = med_lag, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_minimal()
ggplot(cond_lag, aes(x = travel_key_cond, y = mean_log_lag, fill = subj)) +
geom_point(aes(color = subj), size = 2) + geom_line(aes(group = subj, color = subj), size = 1.2) +
facet_grid(phase ~ n_travel_steps)+ theme_minimal()
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
lag_data %>% filter(s_num == 1, trial_num == 1, round == 2, phase == "TRAVEL")
lag_data
colnames(lag_data)
### lets deal with the RTs... (but how)
# just for a given subject histogram all reaction times...
ggplot(cdata, aes(x=lag)) + geom_histogram(binwidth = 10) + xlim(0,500) + facet_wrap( ~ s_num)
lag_data <- cdata %>% select(s_num, rep_number, travel_key_cond, n_travel_steps, phase, trial_num, lag, correct_key, round)
#%>% filter(lag < quantile(lag, .99), lag > quantile(lag, .01)) %>% print()
## filter out for each subject the top 95% of cases also the bottom 5%?
#quantile(lag_data$lag, .98)
lag_data %>% group_by(s_num) %>% summarise(top_lag = quantile(lag, .85), bottom_lag = quantile(lag,.2))
filt_lag <- lag_data %>% group_by(s_num) %>% filter(lag < quantile(lag, .90), lag > quantile(lag, .1)) %>% ungroup()
ggplot(filt_lag, aes(x=lag)) + geom_histogram(binwidth = 10) + xlim(0,500) + facet_wrap( ~ s_num)
ggplot(lag_data %>% filter(phase == "HARVEST"), aes(x=log(lag))) + geom_histogram(binwidth = .1) + xlim(0,10) + facet_wrap( ~ s_num)
## now for each condition, take the mean...
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
lag_data %>% filter(s_num == 1, trial_num == 1, round == 2, phase == "TRAVEL")
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
lag_data %>% filter(s_num == 1, trial_num == 1, round == 2, phase == "TRAVEL")
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "TRAVEL")
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data %>% mutate(correct_key_int = 1*correct_key)
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data %>% mutate(correct_key_int = as.numeric(correct_key))
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.numeric(correct_key))
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
#lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.numeric(correct_key)) %>% print()
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
#lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.integer(as.logical(correct_key))) %>% print()
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
#lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key)) %>% print()
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
#lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int)) %>% print()
# take the cumulative sum
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
#lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = correct_key_sum %% 4) %>% print()
# take the cumulative sum
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
#lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + (correct_key_sum %% 4)) %>% print()
# take the cumulative sum
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
#lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + (correct_key_sum - 1 %% 4)) %>% print()
# take the cumulative sum
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
#lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4)) %>% print()
# take the cumulative sum
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
lag_data <- lag_data %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4)) %>% print()
# take the cumulative sum
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4)) %>% print()
# take the cumulative sum
harvest_round
harvest_round %>% n()
harvest_round$n_correct_seq
harvest_round$n_correct_seq %>% n()
length(harvest_round$n_correct_seq)
n_presses <- length(harvest_round$n_correct_seq)
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 0;
for (i in 1:n_presses){
if (harvest_round$n_correct_seq[i] == 1){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
seq_group
harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 0;
for (i in 1:n_presses){
if (harvest_round$n_correct_seq[i] == 1){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
seq_group
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4)) %>% print()
# take the cumulative sum
####
seq_num_col = vector("int", length = )
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4)) %>% print()
# take the cumulative sum
####
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 0;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq[i] == 1){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
seq_group
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 0;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq[i] == 1){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
harvest_round %>% mutate(seq_num = seq_group)
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 1;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq[i] == 4){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
harvest_round %>% mutate(seq_num = seq_group)
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 1;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq[i] == 4){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
harvest_round %>% mutate(seq_num = seq_group)
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
lag_data %>% filter(s_num == 1) %>% select(correct_key, lag)
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq, (n_correct_seq == 4) & (lag(n_correct_seq) == 4), 1)) %>% print()
## if you have 2 fours in a row, you want it to reset to 1
# take the cumulative sum
####
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
# also want to recode the last harvest press as the first travel press? or just chop off the first travel seq...
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq, (n_correct_seq == 4) & (lag(n_correct_seq) == 4), 1)) %>% print()
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
add_seq_group <- function(harvest_round){
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq = replace(n_correct_seq,
(n_correct_seq == 4) & (lag(n_correct_seq) == 4),
1))
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 1;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq[i] == 4){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
new_harvest_round <- harvest_round %>% mutate(seq_num = seq_group)
return(new_harvest_round)
}
lag_data2 <- lag_data %>% group_by(s_num, trial_num, round, phase) %>%
do(add_seq_group(.)) %>% ungroup()
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
# also want to recode the last harvest press as the first travel press? or just chop off the first travel seq...
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq, (n_correct_seq == 4) & (lag(n_correct_seq) == 4), 1)) %>% print()
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
add_seq_group <- function(harvest_round){
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq = replace(n_correct_seq,
(n_correct_seq == 4) & (lag(n_correct_seq) == 4),
1))
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 1;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq[i] == 4){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
new_harvest_round <- harvest_round %>% mutate(seq_num = seq_group)
return(new_harvest_round)
}
lag_data2 <- lag_data %>% group_by(s_num, trial_num, round, phase) %>%
do(add_seq_group(.)) %>% ungroup()
head(lag_data2)
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
# also want to recode the last harvest press as the first travel press? or just chop off the first travel seq...
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq, (n_correct_seq == 4) & (lag(n_correct_seq) == 4), 1)) %>% print()
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
add_seq_group <- function(harvest_round){
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq,
(n_correct_seq == 4) & (lag(n_correct_seq) == 4),
1))
n_presses <- length(harvest_round$n_correct_seq2)
seq_group <- integer(n_presses)
group_num = 1;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq2[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq2[i] == 4){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
new_harvest_round <- harvest_round %>% mutate(seq_num = seq_group)
return(new_harvest_round)
}
lag_data2 <- lag_data %>% group_by(s_num, trial_num, round, phase) %>%
do(add_seq_group(.)) %>% ungroup()
head(lag_data2)
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
# also want to recode the last harvest press as the first travel press? or just chop off the first travel seq...
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq, (n_correct_seq == 4) & (lag(n_correct_seq) == 4), 1)) %>% print()
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
add_seq_group <- function(harvest_round){
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq,
(n_correct_seq == 4) & (lag(n_correct_seq) == 4),
1))
n_presses <- length(harvest_round$n_correct_seq2)
seq_group <- integer(n_presses)
group_num = 1;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq2[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq2[i] == 4){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
new_harvest_round <- harvest_round %>% mutate(seq_num = seq_group)
return(new_harvest_round)
}
lag_data2 <- lag_data %>% group_by(s_num, trial_num, round, phase) %>%
do(add_seq_group(.)) %>% ungroup()
lag_data2
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
# also want to recode the last harvest press as the first travel press? or just chop off the first travel seq...
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq, (n_correct_seq == 4) & (lag(n_correct_seq) == 4), 1)) %>% print()
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
add_seq_group <- function(harvest_round){
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq,
(n_correct_seq == 4) & (lag(n_correct_seq) == 4),
1))
n_presses <- length(harvest_round$n_correct_seq2)
seq_group <- integer(n_presses)
group_num = 1;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq2[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq2[i] == 1){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
new_harvest_round <- harvest_round %>% mutate(seq_num = seq_group)
return(new_harvest_round)
}
lag_data2 <- lag_data %>% group_by(s_num, trial_num, round, phase) %>%
do(add_seq_group(.)) %>% ungroup()
lag_data2
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
# also want to recode the last harvest press as the first travel press? or just chop off the first travel seq...
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq, (n_correct_seq == 4) & (lag(n_correct_seq) == 4), 1)) %>% print()
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
add_seq_group <- function(harvest_round){
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq,
(n_correct_seq == 4) & (lag(n_correct_seq) == 4),
1))
n_presses <- length(harvest_round$n_correct_seq2)
seq_group <- integer(n_presses)
group_num = 0;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq2[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq2[i] == 1){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
new_harvest_round <- harvest_round %>% mutate(seq_num = seq_group)
return(new_harvest_round)
}
lag_data2 <- lag_data %>% group_by(s_num, trial_num, round, phase) %>%
do(add_seq_group(.)) %>% ungroup()
lag_data2
# the crazy fast RTs come when it's an incorrect key followed by a correct key... so should be able to fix this...
# also want to recode the last harvest press as the first travel press? or just chop off the first travel seq...
# for each phase, sum every 4 RTs
harvest_round <- lag_data %>% filter(s_num == 1, trial_num == 1, round == 1, phase == "HARVEST")
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq2 = replace(n_correct_seq, (n_correct_seq == 4) & (lag(n_correct_seq) == 4), 1)) %>% print()
#harvest_round$n_correct_seq[is.na(harvest_round$n_correct_seq)] = 0
add_seq_group <- function(harvest_round){
harvest_round <- harvest_round %>% mutate(correct_key_int = as.integer(as.logical(correct_key)),
correct_key_sum = cumsum(correct_key_int),
n_correct_seq = 1 + ((correct_key_sum - 1) %% 4),
n_correct_seq = replace(n_correct_seq,
(n_correct_seq == 4) & (lag(n_correct_seq) == 4),
1))
n_presses <- length(harvest_round$n_correct_seq)
seq_group <- integer(n_presses)
group_num = 0;
for (i in 1:n_presses){
if (is.na(harvest_round$n_correct_seq[i])){
seq_group[i] <- 0
}else{
if (harvest_round$n_correct_seq[i] == 1){
group_num <- group_num + 1
}
seq_group[i] <- group_num
}
}
new_harvest_round <- harvest_round %>% mutate(seq_num = seq_group)
return(new_harvest_round)
}
lag_data2 <- lag_data %>% group_by(s_num, trial_num, round, phase) %>%
do(add_seq_group(.)) %>% ungroup()
lag_data2
